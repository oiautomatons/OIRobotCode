#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ir_seeker,      sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     arm_touch,      sensorTouch)
#pragma config(Motor,  motorA,          blockPoll,     tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     drive1,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     drive2,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     flagMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     armMotor,      tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C2_1,    blockServo,           tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    flagServo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    servo3,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "JoystickDriver.c"
#define ROUTE_4

#define WAIT_FOR_START	(true)
#define DEBUG						(false)
#define PLAY_SOUNDS			(true)
#define PID_CONTROL			(false) // Proportional, Integral, and Derivative
#define DRIVE_POWER_FL	(40)
#define DRIVE_POWER_FR	(35)
#define DRIVE_POWER_RL	(40)
#define DRIVE_POWER_RR	(33)
#define TURN_POWERL			(40)
#define TURN_POWERR			(36)
#define START_DELAY			(8000)
#define DRIVE_DELAY			(300)
#define PARK_DISTANCE		(38.0) // Short=38.0, medium=50.5, long=63.0
#define CULM_DISTANCE		(79.0)
#define ALT_DISTANCE1		(28.0)
#define ALT_DISTANCE2		(10.0)
#define ALT_DEGREES			(90.0)


#define PI							(3.14159)
#define WHEEL_BASE			(13.75)
#define WHEEL_DIAM			(4)
#define TICKS_PER_ROTATION	(1440.0)
#define TICKS_PER_INCH	(TICKS_PER_ROTATION/(WHEEL_DIAM*PI))
#define FORWARD					(1)
#define REVERSE					(-1)
#define RIGHT						(1)
#define LEFT						(-1)
#define TIGHT_TURNS			(true)
#define ADJ_YES					(true)
#define ADJ_NO					(false)


#ifdef ROUTE_1
#define ALT_ROUTE				(false)
#define QUICK_ROUTE			(false)
//Connor's portion
#define DIRECTION_A			(FORWARD)
#define TURNTYPE_A			(LEFT)
//Devan's portion
#define DIRECTION_B			(FORWARD)
#define TURNTYPE_B			(RIGHT)
#define TURN_DEGREES_B	(95.0)
#endif /* ROUTE_1 */

#ifdef ROUTE_2
#define ALT_ROUTE				(false)
#define QUICK_ROUTE			(false)
//Connor's portion
#define DIRECTION_A			(FORWARD)
#define TURNTYPE_A			(LEFT)
//Devan's portion
#define DIRECTION_B			(REVERSE)
#define TURNTYPE_B			(RIGHT)
#define TURN_DEGREES_B	(90.0)
#endif /* ROUTE_2 */

#ifdef ROUTE_3
#define ALT_ROUTE				(true)
#define QUICK_ROUTE			(false)
//Connor's portion
#define DIRECTION_A			(FORWARD)
#define TURNTYPE_A			(LEFT)
//Devan's portion
#define DIRECTION_B			(FORWARD)
#define TURNTYPE_B			(RIGHT)
#define TURN_DEGREES_B	(95.0)
#endif /* ROUTE_3 */

#ifdef ROUTE_4
#define ALT_ROUTE				(true)
#define QUICK_ROUTE			(false)
//Connor's portion
#define DIRECTION_A			(FORWARD)
#define TURNTYPE_A			(LEFT)
//Devan's portion
#define DIRECTION_B			(REVERSE)
#define TURNTYPE_B			(RIGHT)
#define TURN_DEGREES_B	(90.0)
#endif /* ROUTE_4 */

int irValue = 0;

void startRobot() {
	if (DEBUG == true) {
		disableDiagnosticsDisplay();
	}

	if (PLAY_SOUNDS == true) {
		nVolume = 4;
	}

	if (PID_CONTROL == true) {
		nPidUpdateInterval = 20; // default is 25ms
		nMotorPIDSpeedCtrl[drive1] = mtrSpeedReg; // mtrSpeedReg or mtrNoReg
		nMotorPIDSpeedCtrl[drive2] = mtrSpeedReg; // mtrSpeedReg or mtrNoReg
	}

	nMotorEncoder[drive1] = 0;
	nMotorEncoder[drive2] = 0;
	motor[drive1] = 0;
	motor[drive2] = 0;
	wait1Msec(100);
	return;
}

int inchesToTicks(float inches) {
	int ticks = inches * TICKS_PER_INCH;
	return ticks;
}

float ticksToInches(int ticks) {
	float inches = ticks / TICKS_PER_INCH;
	return inches;
}

bool readIR(int basket) {
	bool irDetected = false;
	int low, high;

	if (basket <= 2) {
		low = 5; high = 5;
	}
	else {
		low = 5; high = 5;
	}

	irValue = SensorValue(ir_seeker);

	if (PLAY_SOUNDS == true) {
		if (irValue == 4) PlaySound(soundLowBuzz);
		else if (irValue == 5) PlaySound(soundBeepBeep);
		else if (irValue == 6) PlaySound(soundUpwardTones);
	}

	if (irValue >= low && irValue <= high) {
		irDetected = true;
	}

	return irDetected;
}

void metricsDisplay(int ticksLeft, int ticksRight) {
	if (DEBUG == true) {
		eraseDisplay();
		nxtDisplayTextLine(0, "d1=%.02f %d", ticksToInches(nMotorEncoder[drive1]), nMotorEncoder[drive1]);
		nxtDisplayTextLine(1, "in=%.02f %d", ticksToInches(ticksRight), ticksRight);
		nxtDisplayTextLine(3, "d2=%.02f %d", ticksToInches(nMotorEncoder[drive2]), nMotorEncoder[drive2]);
		nxtDisplayTextLine(4, "in=%.02f %d", ticksToInches(ticksLeft), ticksLeft);
		nxtDisplayTextLine(6, "ir=%d", irValue);
	}
	return;
}

void driveDistance(float inches, int direction, bool adjustDistance) {
	int ticksLeft, ticksRight;
	static int deltaLeft = 0, deltaRight = 0;

	ticksLeft = inchesToTicks(inches);
	ticksRight = inchesToTicks(inches);
	if (adjustDistance == ADJ_YES) {
		ticksLeft -= deltaLeft;
		ticksRight -= deltaRight;
	}
	nMotorEncoder[drive1] = 0;
	nMotorEncoder[drive2] = 0;

	if (PID_CONTROL == false) {
		if (direction == FORWARD) {
			motor[drive1] = DRIVE_POWER_FR * direction;
			motor[drive2] = DRIVE_POWER_FL * direction;
		}
		else {
			motor[drive1] = DRIVE_POWER_RR * direction;
			motor[drive2] = DRIVE_POWER_RL * direction;
		}
		while (true) {
			if (abs(nMotorEncoder[drive1]) >= ticksRight) break;
			if (abs(nMotorEncoder[drive2]) >= ticksLeft) break;
		}
	}
	else {
		nMotorEncoderTarget[drive1] = ticksRight * direction;
		nMotorEncoderTarget[drive2] = ticksLeft * direction;
		motor[drive1] = DRIVE_POWER_FR * direction;
		motor[drive2] = DRIVE_POWER_FL * direction;
		while (true) {
			TNxtRunState state1, state2;
			// 0 = runStateIdle
			// 1 = runStateHoldPosition
			// 16 = runStateRampUp
			// 32 = runStateRunning
			// 64 = runStateRampDown
			state1 = nMotorRunState[drive1];
			state2 = nMotorRunState[drive2];
			if (state1 == runStateIdle || state2 == runStateIdle) break;
		}
	}

	motor[drive1] = 0;
	motor[drive2] = 0;
	metricsDisplay(ticksLeft, ticksRight);
	if (adjustDistance == ADJ_YES) {
		deltaLeft = nMotorEncoder[drive2] - ticksLeft;
		deltaRight = nMotorEncoder[drive1] - ticksRight;
	}
	nMotorEncoder[drive1] = 0;
	nMotorEncoder[drive2] = 0;
	if (PLAY_SOUNDS == true) {
		PlaySound(soundBeepBeep);
	}
	wait1Msec(DRIVE_DELAY);
	return;
}

void turnRobot(float degrees, int direction, int turntype) {
	float arc = degrees / 360;
	float circumference, inches;
	int ticks;
	static int deltaLeft = 0, deltaRight = 0;

	if (TIGHT_TURNS) {
		circumference = PI * WHEEL_BASE;
	}
	else {
		circumference = 2 * PI * WHEEL_BASE;
	}

	inches = circumference * arc;
	ticks = inchesToTicks(inches);
	nMotorEncoder[drive1] = 0;
	nMotorEncoder[drive2] = 0;

	if (PID_CONTROL == false) {
		if (turntype == RIGHT) {
			motor[drive2] = TURN_POWERL * direction;
			if (TIGHT_TURNS) motor[drive1] = TURN_POWERR * direction * REVERSE;
		}
		else {
			motor[drive1] = TURN_POWERR * direction;
			if (TIGHT_TURNS) motor[drive2] = TURN_POWERL * direction * REVERSE;
		}
		while (true) {
			if (abs(nMotorEncoder[drive1]) >= ticks) break;
			if (abs(nMotorEncoder[drive2]) >= ticks) break;
		}
	}
	else {
		if (turntype == RIGHT) {
			nMotorEncoderTarget[drive2] = ticks * direction;
			if (TIGHT_TURNS) nMotorEncoderTarget[drive1] = ticks * direction * REVERSE;
			motor[drive2] = TURN_POWERL * direction;
			if (TIGHT_TURNS) motor[drive1] = TURN_POWERR * direction * REVERSE;
		}
		else {
			nMotorEncoderTarget[drive1] = ticks * direction;
			if (TIGHT_TURNS) nMotorEncoderTarget[drive2] = ticks * direction * REVERSE;
			motor[drive1] = TURN_POWERL * direction;
			if (TIGHT_TURNS) motor[drive2] = TURN_POWERR * direction * REVERSE;
		}
		while (true) {
			TNxtRunState state1, state2;
			// 0 = runStateIdle
			// 1 = runStateHoldPosition
			// 16 = runStateRampUp
			// 32 = runStateRunning
			// 64 = runStateRampDown
			state1 = nMotorRunState[drive1];
			state2 = nMotorRunState[drive2];
			if (state1 == runStateIdle && state2 == runStateIdle) break;
		}
	}

	motor[drive1] = 0;
	motor[drive2] = 0;
	metricsDisplay(ticks, ticks);
	deltaLeft = nMotorEncoder[drive2] - ticks;
	deltaRight = nMotorEncoder[drive1] - ticks;
	nMotorEncoder[drive1] = 0;
	nMotorEncoder[drive2] = 0;
	if (PLAY_SOUNDS == true) {
		PlaySound(soundBeepBeep);
	}
	wait1Msec(DRIVE_DELAY);
	return;
}

task main() {
	float pointDistance[] = { 19.0, 10.0, 19.0, 10.0 };
	float totalDistance = 0.0;
	int i;

	startRobot();
	waitForStart();

	if (PLAY_SOUNDS == true) {
		PlaySound(soundBeepBeep);
	}

	if (WAIT_FOR_START == true) {
		wait1Msec(START_DELAY);
	}

	// Connor's portion
	for (i = 0; i < 4; i++) {
		if (i == 0 && ALT_ROUTE == true) {
			driveDistance(ALT_DISTANCE1, FORWARD, ADJ_NO);
			turnRobot(ALT_DEGREES, FORWARD, TURNTYPE_A);
			driveDistance(ALT_DISTANCE2, REVERSE, ADJ_NO);
		}
		else {
			driveDistance(pointDistance[i], DIRECTION_A, ADJ_YES);
		}
		totalDistance += pointDistance[i];

		if (QUICK_ROUTE == true || i == 3 || readIR(i+1) == true) {
			wait1Msec(250);
			servo[blockServo] = 80;
			servo[flagServo] = 65;
			wait1Msec(500);
			servo[blockServo] = 254;
			servo[flagServo] = 65;
			wait1Msec(250);
			break;
		}
	}

	// Devan's portion
	if (DIRECTION_A == DIRECTION_B) {
		driveDistance(CULM_DISTANCE - totalDistance, DIRECTION_B, ADJ_YES);
	}
	else {
		driveDistance(totalDistance - 6.5, DIRECTION_B, ADJ_NO);
	}
	turnRobot(TURN_DEGREES_B, DIRECTION_B, TURNTYPE_B);
	driveDistance(35.0, DIRECTION_B, ADJ_NO);
	turnRobot(TURN_DEGREES_B, DIRECTION_B, TURNTYPE_B);
	driveDistance(PARK_DISTANCE, DIRECTION_B, ADJ_NO);

	if (PLAY_SOUNDS == true) {
		PlaySound(soundBeepBeep);
		wait1Msec(500);
	}
}
